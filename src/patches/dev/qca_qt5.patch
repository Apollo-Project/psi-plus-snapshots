Index: examples/cmssigner/certitem.cpp
===================================================================
--- examples/cmssigner/certitem.cpp	(revision 1336453)
+++ examples/cmssigner/certitem.cpp	(working copy)
@@ -24,6 +24,7 @@
 #include <QtCore>
 #include <QtGui>
 #include <QtCrypto>
+#include <QMessageBox>
 #include "prompter.h"
 
 typedef QMap<CertItemStore::IconType,QPixmap> CertItemIconset;
Index: examples/cmssigner/cmssigner.pro
===================================================================
--- examples/cmssigner/cmssigner.pro	(revision 1336453)
+++ examples/cmssigner/cmssigner.pro	(working copy)
@@ -2,6 +2,9 @@
 CONFIG -= console
 CONFIG += app_bundle
 QT += gui
+contains(QT_VERSION, ^5\\..*) {
+  QT += widgets
+}
 
 include(pkcs11configdlg/pkcs11configdlg.pri)
 
Index: examples/cmssigner/keyselectdlg.cpp
===================================================================
--- examples/cmssigner/keyselectdlg.cpp	(revision 1336453)
+++ examples/cmssigner/keyselectdlg.cpp	(working copy)
@@ -24,6 +24,9 @@
 #include <QtCore>
 #include <QtGui>
 #include <QtCrypto>
+#include <QPushButton>
+#include <QMenu>
+#include <QMessageBox>
 #include "ui_keyselect.h"
 
 #define ONLY_SHOW_KEYBUNDLE
Index: examples/cmssigner/main.cpp
===================================================================
--- examples/cmssigner/main.cpp	(revision 1336453)
+++ examples/cmssigner/main.cpp	(working copy)
@@ -22,6 +22,8 @@
 #include <QtCore>
 #include <QtGui>
 #include <QtCrypto>
+#include <QMessageBox>
+#include <QFileDialog>
 
 #include "ui_mainwin.h"
 #include "certviewdlg.h"
Index: examples/cmssigner/pkcs11configdlg/pkcs11configdlg.cpp
===================================================================
--- examples/cmssigner/pkcs11configdlg/pkcs11configdlg.cpp	(revision 1336453)
+++ examples/cmssigner/pkcs11configdlg/pkcs11configdlg.cpp	(working copy)
@@ -24,6 +24,8 @@
 #include <QtCore>
 #include <QtGui>
 #include <QtCrypto>
+#include <QMessageBox>
+#include <QFileDialog>
 #include "ui_pkcs11config.h"
 
 //----------------------------------------------------------------------------
Index: examples/cmssigner/prompter.cpp
===================================================================
--- examples/cmssigner/prompter.cpp	(revision 1336453)
+++ examples/cmssigner/prompter.cpp	(working copy)
@@ -24,6 +24,9 @@
 #include <QtCore>
 #include <QtGui>
 #include <QtCrypto>
+#include <QMessageBox>
+#include <QInputDialog>
+#include <QApplication>
 
 class Prompter::Private : public QObject
 {
Index: examples/hashtest/hashtest.cpp
===================================================================
--- examples/hashtest/hashtest.cpp	(revision 1336453)
+++ examples/hashtest/hashtest.cpp	(working copy)
@@ -44,7 +44,7 @@
 	else {
 		// this shows the "all in one" approach
 		QString result = QCA::Hash("sha1").hashToString(arg);
-		printf("sha1(\"%s\") = [%s]\n", arg.data(), result.toAscii().data());
+		printf("sha1(\"%s\") = [%s]\n", arg.data(), qPrintable(result));
 	}
 
 	// must always check that an algorithm is supported before using it
@@ -66,7 +66,7 @@
 		QCA::SecureArray resultArray = hashObject.final();
 		// convert the result into printable hexadecimal.
 		QString result = QCA::arrayToHex(resultArray.toByteArray());
-		printf("md5(\"%s\") = [%s]\n", arg.data(), result.toAscii().data());
+		printf("md5(\"%s\") = [%s]\n", arg.data(), qPrintable(result));
 	}
 
 	return 0;
Index: examples/randomtest/randomtest.cpp
===================================================================
--- examples/randomtest/randomtest.cpp	(revision 1336453)
+++ examples/randomtest/randomtest.cpp	(working copy)
@@ -56,7 +56,7 @@
 
 	// To make this viewable, we convert to hexadecimal.
 	std::cout << "A random 10 byte array (in hex): ";
-	std::cout << QCA::Hex().arrayToString(tenBytes).toAscii().data() << std::endl;
+	std::cout << qPrintable(QCA::Hex().arrayToString(tenBytes)) << std::endl;
 
 	// Under some circumstances, you may want to create a
 	// Random object, rather than a static public member function.
Index: plugins/qca-wingss/qca-wingss.cpp
===================================================================
--- plugins/qca-wingss/qca-wingss.cpp	(revision 1336453)
+++ plugins/qca-wingss/qca-wingss.cpp	(working copy)
@@ -337,6 +337,10 @@
 	pInitSecurityInterface.ptr = 0;
 
 	QString securityEntrypoint;
+#if QT_VERSION >= 0x050000
+	securityEntrypoint = QString::fromUtf16((const ushort *)SECURITY_ENTRYPOINTW);
+	pInitSecurityInterface.W = (INIT_SECURITY_INTERFACE_W)(sspi_lib->resolve(securityEntrypoint.toLatin1().data()));
+#else
 	QT_WA(
 		securityEntrypoint = QString::fromUtf16((const ushort *)SECURITY_ENTRYPOINTW);
 		pInitSecurityInterface.W = (INIT_SECURITY_INTERFACE_W)(sspi_lib->resolve(securityEntrypoint.toLatin1().data()));
@@ -344,6 +348,7 @@
 		securityEntrypoint = QString::fromLatin1(SECURITY_ENTRYPOINT_ANSIA);
 		pInitSecurityInterface.A = (INIT_SECURITY_INTERFACE_A)(sspi_lib->resolve(securityEntrypoint.toLatin1().data()));
 	)
+#endif
 	if(!pInitSecurityInterface.ptr)
 	{
 		sspi_lib->unload();
@@ -360,11 +365,15 @@
 	} funcs;
 	funcs.ptr = 0;
 
+#if QT_VERSION >= 0x050000
+	funcs.W = (PMySecurityFunctionTableW)pInitSecurityInterface.W();
+#else
 	QT_WA(
 		funcs.W = (PMySecurityFunctionTableW)pInitSecurityInterface.W();
 	,
 		funcs.A = pInitSecurityInterface.A();
 	)
+#endif
 
 	sspi_log(QString("%1() = %2\n").arg(securityEntrypoint, ptr_toString(funcs.ptr)));
 	if(!funcs.ptr)
@@ -375,11 +384,15 @@
 		return false;
 	}
 
+#if QT_VERSION >= 0x050000
+	sspi.W = funcs.W;
+#else
 	QT_WA(
 		sspi.W = funcs.W;
 	,
 		sspi.A = funcs.A;
 	)
+#endif
 
 	return true;
 }
@@ -398,6 +411,30 @@
 {
 	QList<SspiPackage> out;
 
+#if QT_VERSION >= 0x050000
+	ULONG cPackages;
+	SecPkgInfoW *pPackageInfo;
+	SECURITY_STATUS ret = sspi.W->EnumerateSecurityPackagesW(&cPackages, &pPackageInfo);
+	sspi_log(QString("EnumerateSecurityPackages() = %1\n").arg(SECURITY_STATUS_toString(ret)));
+	if(ret != SEC_E_OK)
+		return out;
+
+	for(int n = 0; n < (int)cPackages; ++n)
+	{
+		SecPkgInfoW *p = &pPackageInfo[n];
+		SspiPackage i;
+		i.name = QString::fromUtf16((const ushort *)p->Name);
+		i.caps = p->fCapabilities;
+		i.version = p->wVersion;
+		i.rpcid = p->wRPCID;
+		i.maxtok = p->cbMaxToken;
+		i.comment = QString::fromUtf16((const ushort *)p->Comment);
+		out += i;
+	}
+
+	ret = sspi.W->FreeContextBuffer(&pPackageInfo);
+	sspi_log(QString("FreeContextBuffer() = %1\n").arg(SECURITY_STATUS_toString(ret)));
+#else
 	QT_WA(
 		ULONG cPackages;
 		SecPkgInfoW *pPackageInfo;
@@ -445,6 +482,7 @@
 		ret = sspi.A->FreeContextBuffer(&pPackageInfo);
 		sspi_log(QString("FreeContextBuffer() = %1\n").arg(SECURITY_STATUS_toString(ret)));
 	)
+#endif
 
 	return out;
 }
@@ -545,6 +583,7 @@
 	{
 		// kerberos only works on unicode-based systems.  we do this
 		//   check so we can lazily use the W api from here on out.
+#if QT_VERSION < 0x050000
 		bool validSystem;
 		QT_WA(
 			validSystem = true;
@@ -553,6 +592,7 @@
 		)
 		if(!validSystem)
 			return ErrorInvalidSystem;
+#endif
 
 		// ensure kerberos is available
 		bool found = false;
Index: src/qca_keystore.cpp
===================================================================
--- src/qca_keystore.cpp	(revision 1336453)
+++ src/qca_keystore.cpp	(working copy)
@@ -308,6 +308,16 @@
 		if(at == -1)
 			return QString();
 		Item &i = items[at];
+#if QT_VERSION >= 0x050000
+		if(v.canConvert<KeyBundle>())
+			return i.owner->writeEntry(i.storeContextId, v.value<KeyBundle>());
+		else if(v.canConvert<Certificate>())
+			return i.owner->writeEntry(i.storeContextId, v.value<Certificate>());
+		else if(v.canConvert<CRL>())
+			return i.owner->writeEntry(i.storeContextId, v.value<CRL>());
+		else if(v.canConvert<PGPKey>())
+			return i.owner->writeEntry(i.storeContextId, v.value<PGPKey>());
+#else
 		if(qVariantCanConvert<KeyBundle>(v))
 			return i.owner->writeEntry(i.storeContextId, qVariantValue<KeyBundle>(v));
 		else if(qVariantCanConvert<Certificate>(v))
@@ -316,6 +326,7 @@
 			return i.owner->writeEntry(i.storeContextId, qVariantValue<CRL>(v));
 		else if(qVariantCanConvert<PGPKey>(v))
 			return i.owner->writeEntry(i.storeContextId, qVariantValue<PGPKey>(v));
+#endif
 		else
 			return QString();
 	}
@@ -783,7 +794,11 @@
 {
 	QString storeId = this->storeId();
 	QString entryId = id();
+#if QT_VERSION >= 0x050000
+	KeyStoreEntryContext *c = (KeyStoreEntryContext *)trackercall("entry", QVariantList() << storeId << entryId).value<void*>();
+#else
 	KeyStoreEntryContext *c = (KeyStoreEntryContext *)qVariantValue<void*>(trackercall("entry", QVariantList() << storeId << entryId));
+#endif
 	if(c)
 		change(c);
 	return isAvailable();
@@ -977,11 +992,25 @@
 	virtual void run()
 	{
 		if(type == EntryList)
+#if QT_VERSION >= 0x050000
+			entryList = trackercall("entryList", QVariantList() << trackerId).value< QList<KeyStoreEntry> >();
+#else
 			entryList = qVariantValue< QList<KeyStoreEntry> >(trackercall("entryList", QVariantList() << trackerId));
+#endif
 		else if(type == WriteEntry)
 		{
 			QVariant arg;
+#if QT_VERSION >= 0x050000
 			if(wentry.type == KeyStoreWriteEntry::TypeKeyBundle)
+				arg.setValue<KeyBundle>(wentry.keyBundle);
+			else if(wentry.type == KeyStoreWriteEntry::TypeCertificate)
+				arg.setValue<Certificate>(wentry.cert);
+			else if(wentry.type == KeyStoreWriteEntry::TypeCRL)
+				arg.setValue<CRL>(wentry.crl);
+			else if(wentry.type == KeyStoreWriteEntry::TypePGPKey)
+				arg.setValue<PGPKey>(wentry.pgpKey);
+#else
+			if(wentry.type == KeyStoreWriteEntry::TypeKeyBundle)
 				qVariantSetValue<KeyBundle>(arg, wentry.keyBundle);
 			else if(wentry.type == KeyStoreWriteEntry::TypeCertificate)
 				qVariantSetValue<Certificate>(arg, wentry.cert);
@@ -989,6 +1018,7 @@
 				qVariantSetValue<CRL>(arg, wentry.crl);
 			else if(wentry.type == KeyStoreWriteEntry::TypePGPKey)
 				qVariantSetValue<PGPKey>(arg, wentry.pgpKey);
+#endif
 
 			// note: each variant in the argument list is resolved
 			//   to its native type.  so even though it looks like
@@ -1205,7 +1235,11 @@
 
 	if(d->trackerId == -1)
 		return QList<KeyStoreEntry>();
+#if QT_VERSION >= 0x050000
+	return trackercall("entryList", QVariantList() << d->trackerId).value< QList<KeyStoreEntry> >();
+#else
 	return qVariantValue< QList<KeyStoreEntry> >(trackercall("entryList", QVariantList() << d->trackerId));
+#endif
 }
 
 bool KeyStore::holdsTrustedCertificates() const
@@ -1213,7 +1247,11 @@
 	QList<KeyStoreEntry::Type> list;
 	if(d->trackerId == -1)
 		return false;
+#if QT_VERSION >= 0x050000
+	list = trackercall("entryTypes", QVariantList() << d->trackerId).value< QList<KeyStoreEntry::Type> >();
+#else
 	list = qVariantValue< QList<KeyStoreEntry::Type> >(trackercall("entryTypes", QVariantList() << d->trackerId));
+#endif
 	if(list.contains(KeyStoreEntry::TypeCertificate) || list.contains(KeyStoreEntry::TypeCRL))
 		return true;
 	return false;
@@ -1224,7 +1262,11 @@
 	QList<KeyStoreEntry::Type> list;
 	if(d->trackerId == -1)
 		return false;
+#if QT_VERSION >= 0x050000
+	list = trackercall("entryTypes", QVariantList() << d->trackerId).value< QList<KeyStoreEntry::Type> >();
+#else
 	list = qVariantValue< QList<KeyStoreEntry::Type> >(trackercall("entryTypes", QVariantList() << d->trackerId));
+#endif
 	if(list.contains(KeyStoreEntry::TypeKeyBundle) || list.contains(KeyStoreEntry::TypePGPSecretKey))
 		return true;
 	return false;
@@ -1235,7 +1277,11 @@
 	QList<KeyStoreEntry::Type> list;
 	if(d->trackerId == -1)
 		return false;
+#if QT_VERSION >= 0x050000
+	list = trackercall("entryTypes", QVariantList() << d->trackerId).value< QList<KeyStoreEntry::Type> >();
+#else
 	list = qVariantValue< QList<KeyStoreEntry::Type> >(trackercall("entryTypes", QVariantList() << d->trackerId));
+#endif
 	if(list.contains(KeyStoreEntry::TypePGPPublicKey))
 		return true;
 	return false;
Index: src/support/console.cpp
===================================================================
--- src/support/console.cpp	(revision 1336453)
+++ src/support/console.cpp	(working copy)
@@ -278,7 +278,11 @@
 
 	SecureArray readSecure(int bytes = -1)
 	{
+#if QT_VERSION >= 0x050000
+		return mycall(worker, "readSecure", QVariantList() << bytes).value<SecureArray>();
+#else
 		return qVariantValue<SecureArray>(mycall(worker, "readSecure", QVariantList() << bytes));
+#endif
 	}
 
 	void writeSecure(const SecureArray &a)
Index: src/support/qpipe.cpp
===================================================================
--- src/support/qpipe.cpp	(revision 1336453)
+++ src/support/qpipe.cpp	(working copy)
@@ -293,11 +293,15 @@
 	// peek them all
 	rec = (INPUT_RECORD *)malloc(count * sizeof(INPUT_RECORD));
 	BOOL ret;
+#if QT_VERSION >= 0x050000
+	ret = PeekConsoleInputW(pipe, rec, count, &i);
+#else
 	QT_WA(
 		ret = PeekConsoleInputW(pipe, rec, count, &i);
 	,
 		ret = PeekConsoleInputA(pipe, rec, count, &i);
 	)
+#endif
 	if(!ret)
 	{
 		free(rec);
@@ -345,11 +349,15 @@
 	}
 	else
 	{
+#if QT_VERSION >= 0x050000
+		dec = 0;
+#else
 		QT_WA(
 			dec = 0;
 		,
 			dec = QTextCodec::codecForLocale()->makeDecoder();
 		)
+#endif
 		own_decoder = true;
 	}
 
@@ -362,12 +370,16 @@
 
 		BOOL ret;
 		DWORD i;
+#if QT_VERSION >= 0x050000
+		ret = ReadConsoleW(pipe, &uni, 1, &i, NULL);
+#else
 		QT_WA(
 			ret = ReadConsoleW(pipe, &uni, 1, &i, NULL);
 		,
 			ret = ReadConsoleA(pipe, &ansi, 1, &i, NULL);
 			use_uni = false;
 		)
+#endif
 		if(!ret)
 		{
 			// if the first read is an error, then report error
@@ -410,6 +422,9 @@
 {
 	DWORD i;
 	BOOL ret;
+#if QT_VERSION >= 0x050000
+	ret = WriteConsoleW(pipe, data, size, &i, NULL);
+#else
 	QT_WA(
 		ret = WriteConsoleW(pipe, data, size, &i, NULL);
 	,
@@ -425,6 +440,7 @@
 				return -1;
 		}
 	)
+#endif
 	if(!ret)
 		return -1;
 	return (int)i; // safe to cast since 'size' is signed
@@ -1036,11 +1052,15 @@
 			// console might need a decoder
 			if(consoleMode)
 			{
+#if QT_VERSION >= 0x050000
+				dec = 0;
+#else
 				QT_WA(
 					dec = 0;
 				,
 					dec = QTextCodec::codecForLocale()->makeDecoder();
 				)
+#endif
 			}
 
 			// pipe reader
Index: src/support/synchronizer.cpp
===================================================================
--- src/support/synchronizer.cpp	(revision 1336453)
+++ src/support/synchronizer.cpp	(working copy)
@@ -58,7 +58,7 @@
 
 	static bool haveFixer(QObject *obj)
 	{
-		return (qFindChild<TimerFixer *>(obj) ? true: false);
+		return obj->findChild<TimerFixer *>() ? true : false;
 	}
 
 	TimerFixer(QObject *_target, TimerFixer *_fp = 0) : QObject(_target)
@@ -180,7 +180,11 @@
 			int timeLeft = qMax(info.interval - info.time.elapsed(), 0);
 			info.fixInterval = true;
 			ed->unregisterTimer(info.id);
+#if QT_VERSION >= 0x050000
+			ed->registerTimer(info.id, timeLeft, Qt::CoarseTimer, target);
+#else
 			ed->registerTimer(info.id, timeLeft, target);
+#endif
 
 #ifdef TIMERFIXER_DEBUG
 			printf("TimerFixer[%p] adjusting [%d] to %d\n", this, info.id, timeLeft);
@@ -239,7 +243,11 @@
 #endif
 			info.fixInterval = false;
 			ed->unregisterTimer(info.id);
+#if QT_VERSION >= 0x050000
+			ed->registerTimer(info.id, info.interval, Qt::CoarseTimer, target);
+#else
 			ed->registerTimer(info.id, info.interval, target);
+#endif
 		}
 
 		info.time.start();
@@ -258,7 +266,11 @@
 			int id = timers[n].id;
 			for(int i = 0; i < edtimers.count(); ++i)
 			{
+#if QT_VERSION >= 0x050000
+				if(edtimers[i].timerId == id)
+#else
 				if(edtimers[i].first == id)
+#endif
 				{
 					found = true;
 					break;
@@ -278,7 +290,11 @@
 		// added?
 		for(int n = 0; n < edtimers.count(); ++n)
 		{
+#if QT_VERSION >= 0x050000
+			int id = edtimers[n].timerId;
+#else
 			int id = edtimers[n].first;
+#endif
 			bool found = false;
 			for(int i = 0; i < timers.count(); ++i)
 			{
@@ -293,7 +309,11 @@
 			{
 				TimerInfo info;
 				info.id = id;
+#if QT_VERSION >= 0x050000
+				info.interval = edtimers[n].interval;
+#else
 				info.interval = edtimers[n].second;
+#endif
 				info.time.start();
 				timers += info;
 #ifdef TIMERFIXER_DEBUG
Index: src/support/syncthread.cpp
===================================================================
--- src/support/syncthread.cpp	(revision 1336453)
+++ src/support/syncthread.cpp	(working copy)
@@ -32,11 +32,15 @@
 	for(int n = 0; n < obj->methodCount(); ++n)
 	{
 		QMetaMethod m = obj->method(n);
+#if QT_VERSION >= 0x050000
+		QByteArray name = m.name();
+#else
 		QByteArray sig = m.signature();
 		int offset = sig.indexOf('(');
 		if(offset == -1)
 			continue;
 		QByteArray name = sig.mid(0, offset);
+#endif
 		if(name != method)
 			continue;
 		if(m.parameterTypes() != argTypes)
@@ -73,7 +77,8 @@
 
 	QGenericReturnArgument retarg;
 	QVariant retval;
-	if(metatype != 0)
+
+	if(metatype && metatype != QMetaType::Void)
 	{
 		retval = QVariant(metatype, (const void *)0);
 		retarg = QGenericReturnArgument(retval.typeName(), retval.data());
Index: tools/qcatool/main.cpp
===================================================================
--- tools/qcatool/main.cpp	(revision 1336453)
+++ tools/qcatool/main.cpp	(working copy)
@@ -1301,14 +1301,22 @@
 
 static bool variant_is_bool(const QVariant &in)
 {
+#if QT_VERSION >= 0x050000
+	if(in.canConvert<QString>() && string_is_bool(in.toString()))
+#else
 	if(qVariantCanConvert<QString>(in) && string_is_bool(in.toString()))
+#endif
 		return true;
 	return false;
 }
 
 static bool variant_is_int(const QVariant &in)
 {
+#if QT_VERSION >= 0x050000
+	if(in.canConvert<QString>() && string_is_int(in.toString()))
+#else
 	if(qVariantCanConvert<QString>(in) && string_is_int(in.toString()))
+#endif
 		return true;
 	return false;
 }
@@ -1418,7 +1426,11 @@
 			newval = prompt_for_bool(QString("bool   ") + prompt, val.toBool());
 		else if(variant_is_int(val))
 			newval = prompt_for_int(QString("int    ") + prompt, val.toInt());
+#if QT_VERSION >= 0x050000
+		else if(val.canConvert<QString>())
+#else
 		else if(qVariantCanConvert<QString>(val))
+#endif
 			newval = prompt_for_string(QString("string ") + prompt, val.toString());
 		else
 			continue; // skip bogus fields
Index: unittest/certunittest/certunittest.cpp
===================================================================
--- unittest/certunittest/certunittest.cpp	(revision 1336453)
+++ unittest/certunittest/certunittest.cpp	(working copy)
@@ -129,24 +129,24 @@
 	    QCOMPARE( ca1.notValidBefore().toString(), QDateTime( QDate( 2001, 8, 17 ), QTime( 8, 30, 39 ), Qt::UTC ).toString() );
 	    QCOMPARE( ca1.notValidAfter().toString(), QDateTime( QDate( 2011, 8, 15 ), QTime( 8, 30, 39 ), Qt::UTC ).toString() );
 
-	    QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::CRLSign), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::ServerAuth), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::ClientAuth), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::EmailProtection), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::CRLSign) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::ServerAuth) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::ClientAuth) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::EmailProtection) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    // no policies on this cert
 	    QCOMPARE( ca1.policies().count(), 0 );
@@ -184,24 +184,24 @@
 
 	    QCOMPARE( ca1.pathLimit(), 0 );
 
-	    QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::CRLSign), (QBool)true );
-	    QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::ServerAuth), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::ClientAuth), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::EmailProtection), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( ca1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::CRLSign) == true, true );
+	    QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::ServerAuth) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::ClientAuth) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::EmailProtection) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( ca1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning) == true, false );
 	}
     }
 }
@@ -230,39 +230,39 @@
 	    QCOMPARE( client1.notValidBefore().toString(), QDateTime( QDate( 2001, 8, 17 ), QTime( 8, 32, 38 ), Qt::UTC ).toString() );
 	    QCOMPARE( client1.notValidAfter().toString(), QDateTime( QDate( 2006, 8, 16 ), QTime( 8, 32, 38 ), Qt::UTC ).toString() );
 
-	    QCOMPARE( client1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::DataEncipherment), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::CRLSign), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::ServerAuth), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::ClientAuth), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::EmailProtection), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( client1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::DataEncipherment) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::CRLSign) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::ServerAuth) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::ClientAuth) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::EmailProtection) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    // no policies on this cert
 	    QCOMPARE( client1.policies().count(), 0 );
 
 	    QCA::CertificateInfo subject1 = client1.subjectInfo();
 	    QCOMPARE( subject1.isEmpty(), false );
-	    QCOMPARE( subject1.values(QCA::Country).contains("de"), (QBool)true );
-	    QCOMPARE( subject1.values(QCA::Organization).contains("InsecureTestCertificate"), (QBool)true );
-	    QCOMPARE( subject1.values(QCA::CommonName).contains("Insecure User Test Cert"), (QBool)true );
+	    QCOMPARE( subject1.values(QCA::Country).contains("de") == true, true );
+	    QCOMPARE( subject1.values(QCA::Organization).contains("InsecureTestCertificate") == true, true );
+	    QCOMPARE( subject1.values(QCA::CommonName).contains("Insecure User Test Cert") == true, true );
 
 	    QCA::CertificateInfo issuer1 = client1.issuerInfo();
 	    QCOMPARE( issuer1.isEmpty(), false );
-	    QCOMPARE( issuer1.values(QCA::Country).contains("de"), (QBool)true );
-	    QCOMPARE( issuer1.values(QCA::Organization).contains("InsecureTestCertificate"), (QBool)true );
-	    QCOMPARE( issuer1.values(QCA::CommonName).contains("For Tests Only"), (QBool)true );
+	    QCOMPARE( issuer1.values(QCA::Country).contains("de") == true, true );
+	    QCOMPARE( issuer1.values(QCA::Organization).contains("InsecureTestCertificate") == true, true );
+	    QCOMPARE( issuer1.values(QCA::CommonName).contains("For Tests Only") == true, true );
 
 	    QByteArray subjectKeyID = QCA::Hex().stringToArray("889E7EF729719D7B280F361AAE6D00D39DE1AADB").toByteArray();
 	    QCOMPARE( client1.subjectKeyId(), subjectKeyID );
@@ -338,24 +338,24 @@
 	    QCOMPARE( client2.notValidBefore().toString(), QDateTime( QDate( 2007, 7, 22 ), QTime( 3, 30, 29 ), Qt::UTC ).toString() );
 	    QCOMPARE( client2.notValidAfter().toString(), QDateTime( QDate( 2012, 7, 20 ), QTime( 3, 30, 29 ), Qt::UTC ).toString() );
 
-	    QCOMPARE( client2.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::DataEncipherment), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::CRLSign), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::ServerAuth), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::ClientAuth), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::EmailProtection), (QBool)true );
-	    QCOMPARE( client2.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( client2.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( client2.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( client2.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::DataEncipherment) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::KeyCertificateSign) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::CRLSign) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::ServerAuth) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::ClientAuth) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::EmailProtection) == true, true );
+	    QCOMPARE( client2.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( client2.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( client2.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    // no policies on this cert
 	    QCOMPARE( client2.policies().count(), 0 );
@@ -470,24 +470,24 @@
             QCOMPARE( ca1.notValidBefore().toString(), QDateTime( QDate( 2001, 8, 17 ), QTime( 8, 30, 39 ), Qt::UTC ).toString() );
             QCOMPARE( ca1.notValidAfter().toString(), QDateTime( QDate( 2011, 8, 15 ), QTime( 8, 30, 39 ), Qt::UTC ).toString() );
 
-            QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-            QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-            QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-            QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign), (QBool)true );
-            QCOMPARE( ca1.constraints().contains(QCA::CRLSign), (QBool)true );
-            QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::ServerAuth), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::ClientAuth), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::CodeSigning), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::EmailProtection), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-            QCOMPARE( ca1.constraints().contains(QCA::IPSecUser), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::TimeStamping), (QBool)false );
-            QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+            QCOMPARE( ca1.constraints().contains(QCA::DigitalSignature) == true, true );
+            QCOMPARE( ca1.constraints().contains(QCA::NonRepudiation) == true, true );
+            QCOMPARE( ca1.constraints().contains(QCA::KeyEncipherment) == true, true );
+            QCOMPARE( ca1.constraints().contains(QCA::DataEncipherment) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::KeyAgreement) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::KeyCertificateSign) == true, true );
+            QCOMPARE( ca1.constraints().contains(QCA::CRLSign) == true, true );
+            QCOMPARE( ca1.constraints().contains(QCA::EncipherOnly) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::DecipherOnly) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::ServerAuth) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::ClientAuth) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::CodeSigning) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::EmailProtection) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::IPSecTunnel) == true, false);
+            QCOMPARE( ca1.constraints().contains(QCA::IPSecUser) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::TimeStamping) == true, false );
+            QCOMPARE( ca1.constraints().contains(QCA::OCSPSigning) == true, false );
 
             // no policies on this cert
             QCOMPARE( ca1.policies().count(), 0 );
@@ -518,24 +518,24 @@
 
 	    QCOMPARE( client1.commonName(), QString("Valid RFC822 nameConstraints EE Certificate Test21") );
 
-	    QCOMPARE( client1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::DataEncipherment), (QBool)true );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::CRLSign), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::ServerAuth), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::ClientAuth), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::EmailProtection), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( client1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( client1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( client1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::DataEncipherment) == true, true );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::CRLSign) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::ServerAuth) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::ClientAuth) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::EmailProtection) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( client1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( client1.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    QCOMPARE( client1.policies().count(), 1 );
 	    QCOMPARE( client1.policies().at(0), QString("2.16.840.1.101.3.2.1.48.1") );
@@ -636,24 +636,24 @@
 
             QCOMPARE( client1.commonName(), QString("sip1.su.se") );
 
-            QCOMPARE( client1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-            QCOMPARE( client1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-            QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-            QCOMPARE( client1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::CRLSign), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::ServerAuth), (QBool)true );
-            QCOMPARE( client1.constraints().contains(QCA::ClientAuth), (QBool)true );
-            QCOMPARE( client1.constraints().contains(QCA::CodeSigning), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::EmailProtection), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-            QCOMPARE( client1.constraints().contains(QCA::IPSecUser), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::TimeStamping), (QBool)false );
-            QCOMPARE( client1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+            QCOMPARE( client1.constraints().contains(QCA::DigitalSignature) == true, true );
+            QCOMPARE( client1.constraints().contains(QCA::NonRepudiation) == true, true );
+            QCOMPARE( client1.constraints().contains(QCA::KeyEncipherment) == true, true );
+            QCOMPARE( client1.constraints().contains(QCA::DataEncipherment) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::KeyAgreement) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::KeyCertificateSign) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::CRLSign) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::EncipherOnly) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::DecipherOnly) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::ServerAuth) == true, true );
+            QCOMPARE( client1.constraints().contains(QCA::ClientAuth) == true, true );
+            QCOMPARE( client1.constraints().contains(QCA::CodeSigning) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::EmailProtection) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::IPSecTunnel) == true, false);
+            QCOMPARE( client1.constraints().contains(QCA::IPSecUser) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::TimeStamping) == true, false );
+            QCOMPARE( client1.constraints().contains(QCA::OCSPSigning) == true, false );
 
             QCOMPARE( client1.policies().count(), 1 );
 
@@ -773,39 +773,39 @@
 	    QCOMPARE( server1.notValidBefore().toString(), QDateTime( QDate( 2001, 8, 17 ), QTime( 8, 46, 24 ), Qt::UTC ).toString() );
 	    QCOMPARE( server1.notValidAfter().toString(), QDateTime( QDate( 2006, 8, 16 ), QTime( 8, 46, 24 ), Qt::UTC ).toString() );
 
-	    QCOMPARE( server1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::NonRepudiation), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyAgreement), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::CRLSign), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::ServerAuth), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::ClientAuth), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::EmailProtection), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( server1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::NonRepudiation) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::DataEncipherment) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyAgreement) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyCertificateSign) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::CRLSign) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::ServerAuth) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::ClientAuth) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::EmailProtection) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    // no policies on this cert
 	    QCOMPARE( server1.policies().count(), 0 );
 
 	    QCA::CertificateInfo subject1 = server1.subjectInfo();
 	    QCOMPARE( subject1.isEmpty(), false );
-	    QCOMPARE( subject1.values(QCA::Country).contains("de"), (QBool)true );
-	    QCOMPARE( subject1.values(QCA::Organization).contains("InsecureTestCertificate"), (QBool)true );
-	    QCOMPARE( subject1.values(QCA::CommonName).contains("Insecure Server Cert"), (QBool)true );
+	    QCOMPARE( subject1.values(QCA::Country).contains("de") == true, true );
+	    QCOMPARE( subject1.values(QCA::Organization).contains("InsecureTestCertificate") == true, true );
+	    QCOMPARE( subject1.values(QCA::CommonName).contains("Insecure Server Cert") == true, true );
 
 	    QCA::CertificateInfo issuer1 = server1.issuerInfo();
 	    QCOMPARE( issuer1.isEmpty(), false );
-	    QCOMPARE( issuer1.values(QCA::Country).contains("de"), (QBool)true );
-	    QCOMPARE( issuer1.values(QCA::Organization).contains("InsecureTestCertificate"), (QBool)true );
-	    QCOMPARE( issuer1.values(QCA::CommonName).contains("For Tests Only"), (QBool)true );
+	    QCOMPARE( issuer1.values(QCA::Country).contains("de") == true, true );
+	    QCOMPARE( issuer1.values(QCA::Organization).contains("InsecureTestCertificate") == true, true );
+	    QCOMPARE( issuer1.values(QCA::CommonName).contains("For Tests Only") == true, true );
 
 	    QByteArray subjectKeyID = QCA::Hex().stringToArray("0234E2C906F6E0B44253BE04C0CBA7823A6DB509").toByteArray();
 	    QCOMPARE( server1.subjectKeyId(), subjectKeyID );
@@ -876,24 +876,24 @@
 	    QCOMPARE( server1.notValidBefore().toString(), QDateTime( QDate( 2007, 7, 22 ), QTime( 6, 5, 39 ), Qt::UTC ).toString() );
 	    QCOMPARE( server1.notValidAfter().toString(), QDateTime( QDate( 2012, 7, 20 ), QTime( 6, 5, 39 ), Qt::UTC ).toString() );
 
-	    QCOMPARE( server1.constraints().contains(QCA::DigitalSignature), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::NonRepudiation), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyEncipherment), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::DataEncipherment), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyAgreement), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::KeyCertificateSign), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::CRLSign), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::EncipherOnly), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::DecipherOnly), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::ServerAuth), (QBool)true );
-	    QCOMPARE( server1.constraints().contains(QCA::ClientAuth), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::CodeSigning), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::EmailProtection), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecEndSystem), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecTunnel), (QBool)false);
-	    QCOMPARE( server1.constraints().contains(QCA::IPSecUser), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::TimeStamping), (QBool)false );
-	    QCOMPARE( server1.constraints().contains(QCA::OCSPSigning), (QBool)false );
+	    QCOMPARE( server1.constraints().contains(QCA::DigitalSignature) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::NonRepudiation) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyEncipherment) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::DataEncipherment) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyAgreement) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::KeyCertificateSign) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::CRLSign) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::EncipherOnly) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::DecipherOnly) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::ServerAuth) == true, true );
+	    QCOMPARE( server1.constraints().contains(QCA::ClientAuth) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::CodeSigning) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::EmailProtection) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecEndSystem) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecTunnel) == true, false);
+	    QCOMPARE( server1.constraints().contains(QCA::IPSecUser) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::TimeStamping) == true, false );
+	    QCOMPARE( server1.constraints().contains(QCA::OCSPSigning) == true, false );
 
 	    // no policies on this cert
 	    QCOMPARE( server1.policies().count(), 0 );
Index: unittest/hashunittest/hashunittest.cpp
===================================================================
--- unittest/hashunittest/hashunittest.cpp	(revision 1336453)
+++ unittest/hashunittest/hashunittest.cpp	(working copy)
@@ -114,7 +114,11 @@
 
     foreach(QString provider, providersToTest) {
 	if(!QCA::isSupported("md2", provider))
+#if QT_VERSION >= 0x050000
+	    QSKIP(QString("MD2 not supported for "+provider).toLocal8Bit());
+#else
 	    QSKIP(QString("MD2 not supported for "+provider).toLocal8Bit(), SkipSingle);
+#endif
 	QString hashResult = QCA::Hash("md2", provider).hashToString(input);
 	QCOMPARE( hashResult, expectedHash );
     }
Index: unittest/keygenunittest/keygenunittest.cpp
===================================================================
--- unittest/keygenunittest/keygenunittest.cpp	(revision 1336453)
+++ unittest/keygenunittest/keygenunittest.cpp	(working copy)
@@ -61,7 +61,11 @@
     if(!QCA::isSupported("pkey") ||
        !QCA::PKey::supportedTypes().contains(QCA::PKey::RSA) ||
        !QCA::PKey::supportedIOTypes().contains(QCA::PKey::RSA))
+#if QT_VERSION >= 0x050000
+        QSKIP("RSA not supported!");
+#else
         QSKIP("RSA not supported!", SkipAll);
+#endif
 
     QCA::PrivateKey priv1 = keygen.createRSA( 1024, 65537 );
     QCA::RSAPrivateKey rsa1 = priv1.toRSA();
@@ -91,7 +95,11 @@
     if(!QCA::isSupported("pkey") ||
        !QCA::PKey::supportedTypes().contains(QCA::PKey::DSA) ||
        !QCA::PKey::supportedIOTypes().contains(QCA::PKey::DSA))
+#if QT_VERSION >= 0x050000
+	QSKIP("DSA not supported!");
+#else
 	QSKIP("DSA not supported!", SkipAll);
+#endif
 
     QCA::DLGroup group = keygen.createDLGroup( QCA::DSA_512 );
     QCA::PrivateKey priv2 = keygen.createDSA( group );
@@ -121,7 +129,11 @@
     if(!QCA::isSupported("pkey") ||
        !QCA::PKey::supportedTypes().contains(QCA::PKey::DH) ||
        !QCA::PKey::supportedIOTypes().contains(QCA::PKey::DH))
-        QSKIP("DH not supported!", SkipAll);
+#if QT_VERSION >= 0x050000
+	QSKIP("DH not supported!");
+#else
+	QSKIP("DH not supported!", SkipAll);
+#endif
 
     QCA::DLGroup group = keygen.createDLGroup( QCA::IETF_1024 );
     QCA::PrivateKey priv3 = keygen.createDH( group );
--- src/support/syncthread.cpp
+++ src/support/syncthread.cpp
@@ -62,12 +62,20 @@ bool invokeMethodWithVariants(QObject *obj, const QByteArray &method, const QVar
 		argTypes += args[n].typeName();
 
 	// get return type
-	int metatype = 0;
+	int metatype = QMetaType::Void;
 	QByteArray retTypeName = methodReturnType(obj->metaObject(), method, argTypes);
+#if QT_VERSION >= 0x050000
+	if(!retTypeName.isEmpty() && retTypeName != "void")
+#else
 	if(!retTypeName.isEmpty())
+#endif
 	{
 		metatype = QMetaType::type(retTypeName.data());
-		if(metatype == 0) // lookup failed
+#if QT_VERSION >= 0x050000
+		if(metatype == QMetaType::UnknownType) // lookup failed
+#else
+		if(metatype == QMetaType::Void) // lookup failed
+#endif
 			return false;
 	}
 
@@ -78,7 +86,7 @@ bool invokeMethodWithVariants(QObject *obj, const QByteArray &method, const QVar
 	QGenericReturnArgument retarg;
 	QVariant retval;
 
-	if(metatype && metatype != QMetaType::Void)
+	if(metatype != QMetaType::Void)
 	{
 		retval = QVariant(metatype, (const void *)0);
 		retarg = QGenericReturnArgument(retval.typeName(), retval.data());
diff --git a/unittest/metatype/metatype.cpp b/unittest/metatype/metatype.cpp
index 08660f0..1502cf6 100644
--- unittest/metatype/metatype.cpp
+++ unittest/metatype/metatype.cpp
@@ -87,8 +87,11 @@ void MetaTypeUnitTest::returnTypeTest()
     QList<QByteArray> args;
 
     // returns a null type name because that is what void does...
+#if QT_VERSION >= 0x050000
+    QCOMPARE( QByteArray( "void" ), QCA::methodReturnType( testClass1.metaObject(), QByteArray( "voidMethod" ), args ) );
+#else
     QCOMPARE( QByteArray(), QCA::methodReturnType( testClass1.metaObject(), QByteArray( "voidMethod" ), args ) );
-
+#endif
     QCOMPARE( QByteArray( "QString" ), QCA::methodReturnType( testClass1.metaObject(), QByteArray( "qstringMethod" ), args ) );
 
     // returns a null type, because args don't match
